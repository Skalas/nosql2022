* Bases de Datos de Grafos - Neo4j

Mientras que para las BDs relacionales, cada registro es un ejemplo o instancia de una entidad, o una tabla, y las relaciones son solo llaves copiadas entre tablas, para las BDs de grafos lo que se almacena es la conexi칩n o la relaci칩n entre 2 nodos.

Encima de esto, dado que cada nodo puede tener diferentes atributos, las bases de datos de grafos *no tienen esquema*, lo cual las vuelve un poco lentas para la escritura VS las BDs relacionales, sobre todo cuando llegamos al orden de millones de registros, debido a que cada nodo tendr치 estructura diferente y no tenemos una estructura definida y fija como una tabla.

** Otros ejemplos de BDs de grafos

- Amazon Neptune
- ArangoDB
- TerminusDB

** El modelo de datos de una BD de grafos

Los componentes principales de una BD de grafos es:

1. *Nodos:* los objetos principales en un dise침o de grafos. Representan una entidad particular (una instancia de un objeto, o una instancia de un sustantivo - i.e. no representan un /tipo de objeto/ o /clase/, sino el /objeto en s칤/, no un tipo de /marca/ropa/deportiva/ sino /adidas/, o /Patagonia/).
2. *Edges:* la conexi칩n entre 2 nodos. Representa una relaci칩n (un verbo) entre 2 objetos.
3. *Labels/Etiquetas:* podemos usarlas para definir una /clase/ o /tipo de objeto/ y as칤 agrupar nodos con caracter칤sticas comunes.
4. *Propiedades:* dentro de cada /nodo/ o /edge/ podemos tener un diccionario /llave:valor/ con propiedades que califican a cada uno.

*** Modelo l칩gico de grafos

Supongamos la siguiente narrativa:

#+begin_quote
"Si, mira, quiero una red social mamalona, como facebook, pero que llamaremos "el libro de caras del bienestar" ya sabes? que nuestros datos no est칠n en servidores gringos neoliberales, sino en infraestructura 100% mexicana. Primero tendremos solamente *Personas* y *Lugares*, y cada *Persona* tendr치 su *nombre*, *lugar*, *g칠nero* y *correo electr칩nico*; mientras que cada *Lugar* tendr치 *nombre*, *latitud* y *longitud*. Las *Personas* estar치n conectadas por una relaci칩n llamada *Amistad*, donde podemos tener *a침os de amistad*, y mientras que los *Lugares* estar치n conectados a las *Personas* a trav칠s de la relaci칩n llamada *Vive en*, sin atributos, de momento."
#+end_quote

C칩mo podemos representar esto?

**** Nodos
Ustedes...
**** Nodos
#+DOWNLOADED: screenshot @ 2022-11-09 23:42:36
[[file:images/20221109-234236_screenshot.png]]
**** Edges
Ustedes...
**** Edges
#+DOWNLOADED: screenshot @ 2022-11-09 23:42:13
[[file:images/20221109-234213_screenshot.png]]
**** Labels
Ustedes...
**** Labels

#+DOWNLOADED: screenshot @ 2022-11-09 23:43:24
[[file:images/20221109-234324_screenshot.png]]

**** Properties
Ustedes...
**** Properties

#+DOWNLOADED: screenshot @ 2022-11-09 23:43:32
[[file:images/20221109-234332_screenshot.png]]

Ya podemos ver las diferencias entre los modelos relacionales y los de grafos.

Desde el punto de vista l칩gico, el modelo de grafos no promueve la *generalizaci칩n*, es decir, el centrarnos en *clases* o *entidades*, sino en los ejemplos espec칤ficos de cada clase o entidad, sino que promueve la *especializaci칩n*. No nos importa que un /Person/ viva en un /Location/, sino que /Karl Marx/ vive en /Alemania/, y solo como *conveniencia* usamos la etiqueta /Person/ para agrupar a Karl Marx junto a, a aunque se revuelque en su tumba, Adam Smith, Keynes, Miller, Modigliani, /et al/.

*** Modelo f칤sico de grafos

Aparte de tener un nodo por cada /Person/, la diferencia m치s grande es al recorrer relaciones o *edges*.

La forma de registrar que 2 nodos est치n relacionados con un edge en bases de datos de grafos es utilizando *apuntadores*, esto es, direcciones de memoria que nos llevan de un lugar dentro de ella donde est치 un nodo, a otro lugar en la memoria donde est치 otro nodo.
Esto se le llama [[https://thomasvilhena.com/2019/08/index-free-adjacency][Index-free Adjacency]]. Esto es, no necesitamos un diccionario, ni una operaci칩n de intersecci칩n de conjuntos, ni un mapeo de columnas, como en los modelos relacionales, para poder ir de una tabla a otra.

En las BDs de grafos, las relaciones se encuentran ya f칤sicamente en memoria, expresadas con el objeto de m치s bajo nivel que nuestra m치quina puede utilizar. Esto implica que el recorrer un grafo para ir de nodo en nodo recolectando informaci칩n, el performance *NO DEPENDE DEL TAMA칌O DEL GRAFO*! Podemos decir que tiene un running time linear de *O(n)*, donde ~n~ es el num de edges a recorrer, que siempre ser치 m치s reducido que la N involucrada en un ~JOIN~.


En contraste, las BDs relacionales al viajar de una tabla a otra con ~JOIN~, estamos utilizando una operaci칩n de intersecci칩n para ver en qu칠 parte los 2 칤ndices de las 2 llaves de la relaci칩n se traslapan, y por tanto su performance *DISMINUYE A MEDIDA QUE HAY M츼S REGISTROS*. Podemos decir que los ~JOIN~ tienen un running time de *O(log n)* cuando usamos llaves indexadas, y *O(n^2)* cuando son /soft joins/ entre columnas que no son llaves o tienen 칤ndices.

** Cu치ndo S칈 debemos usar una BD de grafos?

*** 1. Cuando mis datos est칠n altamente conectados

Esto es, cuando el elemento central para nuestro an치lisis sea la conexi칩n o la relaci칩n entre entidades particulares, y por tanto nuestros datos *no sean transaccionales*, entonces probablemente nos conviene una BD de grafos. Frecuentemente solo es necesario guardar los datos y realizar an치lisis sofisticado despu칠s.

*** 2. Cuando la lectura sea m치s importante que la escritura

Si mi problema es /transaccional/ en su naturaleza, y los anal칤ticos que voy a ejecutar en estos datos con ayuda de ~JOIN~ no recorren la mayor칤a de las entidades, entonces quiz치 no requiera una BD de grafos.

*** 3. Cuando mi modelo de datos cambie constantemente

Dado que las BDs de grafos *no tienen esquema*, al igual que las document databases, y por tanto para cada nodo o edge podemos agregar atributos a como deseemos, ser치n adecuadas cuando tengamos alto nivel de incertidumbre sobre la definici칩n de nuestros datos, y a la postre nos permitir치n que no todos los nodos tengan forzosamente valores en todos los atributos, y los que tengan, que no sean consistentes en cuanto a los tipos (i.e. el nodo "Adam Smith" tendr치 el atributo /tiene_sentido_del_humor/ en *FALSE*, mientras que el nodo "Milton Friedmann" lo tendr치 en *TRUE*, y finalmente, el nodo "Karl Marx" lo tendr치 en *null*).

** Cu치ndo NO debemos usar una BD de grafos?

*** 1. Cuando mis anal칤ticos hagan /table scan/ constantemente

Cuando los anal칤ticos que vaya a correr sobre esos datos impliquen constantes /table scans/ sean parciales o /full/, o secuenciales o con 칤ndices, entonces una BD de grafos puede que no sea la mejor opci칩n.

*** 2. Cuando mis b칰squedas por ID sean constantes

Como vimos en nuestra intro a BDs columnares, los queries propios de una soluci칩n transaccional siempre obtienen todo el rengl칩n, no se centran en relaciones, y frecuentemente buscar치n un ID en toda la tabla. Esto es porque este tipo de queries no aprovecha el performance que dan las BDs de grafos para recorrer varios nodos.

*** 3. Cuando debamos almacenar atributos de gran tama침o

Por ejemplo, si para un nodo hipot칠tico "AMLO" debemos poner un atributo /ma침anera/, y ah칤 debemos de colocar TODAS esas conferencias, resultar치 en un atributo de varios cientos de gigas. El precio de este almacenamiento es alto comparado con la capacidad de movernos y viajar a lo largo de nodos para recoger informaci칩n.

** 丘멆잺 Ya se dieron cuenta? 丘멆잺

Ya se dieron cuenta que todas las BDs alternas a PostgreSQL est치n orientadas a anal칤ticos?

Entonces hace todo el sentido del mundo que tengamos al frente de nuestra administraci칩n de datos una BD relacional para capturar TODO LO TRANSACCIONAL, y luego, dependiendo del tipo de anal칤ticos que deseemos hacer, mover estos datos a una BD que propicie dicha actividad.

1. Alimentar dashboards o modelos de ML: MonetDB o BDs columnares
2. Redes de corrupci칩n/fraude o investigaciones judiciales: Neo4j o BDs de grafos
3. Visualizaci칩n de actividad web o de APIs: MongoDB o BDs de documentos

Pero necesitamos un "buffer" intermedio para no cargarle la mano a ese PostgreSQL. Ese buffer intermedio es el Data Lake que veremos al rato 游땔.

** Instalando Neo4j en AWS EC2
*** Abrir su cuenta de AWS.

*** Instalar Neo4j

Ejecutamos los siguientes comandos en la terminal:

Primero garantizamos las llaves para el intercambio

#+begin_src shell
curl -fsSL https://debian.neo4j.com/neotechnology.gpg.key |sudo gpg --dearmor -o /usr/share/keyrings/neo4j.gpg
#+end_src

Luego agregamos los repositorios de neo4j a nuestro ubuntu

#+begin_src shell
  echo "deb [signed-by=/usr/share/keyrings/neo4j.gpg] https://debian.neo4j.com stable 4.1" | sudo tee -a /etc/apt/sources.list.d/neo4j.list
#+end_src

Actualizamos la lista de paquetes que ve el sistema

#+begin_src shell
sudo apt update
#+end_src

Finalmente, podemos instalar Neo4j:

#+begin_src shell
  sudo apt install neo4j
#+end_src

Si queremos que cuando reiniciemos la m치quina, nuestro neo4j viva, hacemos esto:

#+begin_src shell
sudo systemctl enable neo4j.service
#+end_src

E iniciamos el servicio.
#+begin_src shell
sudo systemctl start neo4j.service
#+end_src

*** Conect치ndonos a Neo4j

Antes de conectarnos debemos modificar el archivo ~/etc/neo4j/neo4j.conf~ para que Neo4j acepte conexiones de todo el mundo 游깷:

#+begin_src shell
  sudo nano /etc/neo4j/neo4j.conf
#+end_src
Hay que buscar la siguiente l칤nea y descomentarla (quitarle el ~*~):

#+begin_src shell
*dbms.default_listen_address=0.0.0.0
#+end_src

Y reiniciar el server

#+begin_src shell
  sudo systemctl restart neo4j
#+end_src

Ahora si, conect칠monos a Neo4j.

Vamos a abrir un browser y entrar a ~https://[IP ADDRESS]:7474~. Nos va a pedir user y password. Los de default son ~neo4j~/~neo4j~, pero en cuanto los usemos, Neo4j nos va a pedir que los cambiemos.

Lo que responde en el puerto ~7474~ es solamente un cliente ligero web hacia Neo4j, no el Neo4j como tal.

Ese responde en el ~7687~, a trav칠s de un servidorsito de conexiones llamado ~Bolt~, con el URL ~jdbc:neo4j:bolt://[IP ADDRESS]:7687/~.

** Cargando la versi칩n de grafos de Northwind

Los cuates de Neo4j hicieron una versi칩n de grafos de Neo4j. No tiene todas las tablas, pero es suficiente para contrastar los paradigas relacionales y de grafos.


#+DOWNLOADED: screenshot @ 2022-11-10 00:08:51
[[file:images/20221110-000851_screenshot.png]]

Vamos a establecer algunas similitudes con SQL antes de continuar:

*** Similitudes con SQL

1. Un registro es un /Node/
2. El nombre de una tabla es un /Label/
3. Un ~join~ o ~foreign key~ es un /edge/ o /relationship/

En particular, al tratarse de la BD de Northwind:

4. Cada registro de la tabla ~orders~ en la BD de Northwind se vuelve un /Node/ con /Label/ ~Order~ en nuestro modelo de grafos
   - Y as칤 sucesivamente con el resto de las tablas
5. El ~join~ entre ~suppliers~ y ~products~ se convierte en un /edge/ o /relationship/ llamado ~SUPPLIES~ (un ~supplier~ ~SUPPLIES~ N ~products~), y as칤 sucesivamente con otras tablas, salvo los siguientes casos especiales:
6. El ~join~ recursivo entre ~employees~ y ~employees~ se convierte en un /edge/ con el nombre ~REPORTS_TO~.
7. La tabla intermedia ~order_details~ que soporta la relaci칩n *N:M* entre ~products~ y ~orders~ desaparece y se convierte en un /edge/ o /relationship/ llamado ~CONTAINS~ y con atributos ~unitPrice~, ~quantity~, ~discount~.

Neo4j est치 construido casi en su totalidad en Java, por lo que ver este ~camelCaseEnLosAtributos~ no es extra침o, como tampoco lo es que los nombres de los /Labels/ est칠n en may칰scula, porque su an치logo en grafos son *Clases*, y sabemos que las clases en Java van con may칰scula inicial.

De esta forma, tenemos el siguiente diagrama de grafos que representa nuestra BD de Northwind:


#+DOWNLOADED: screenshot @ 2022-11-10 00:09:58
[[file:images/20221110-000958_screenshot.png]]

*** Diferencias con SQL

1. No hay nulos! Un nulo, al ser la ausencia de algo, es simplemente la ausencia del atributo, o del /node/ o de un /edge/.
2. Dada la "Index-free Adjacency", sabemos qu칠 /nodes/ tienen particular /relationship/ con otro /node/, en lugar de hacer un ~join~ y realizar la b칰squeda de overlap entre 1 llave primaria de una tabla y la llave for치nea de otra tabla.
3. Aunque puede haber normalizaci칩n justo como en el modelo E-R, 칠sta no es forzosa ni r칤gida, y consiste principalmente en convertir /attributes/ en /nodes/, aunque al hacer esto debemos tener en mente que al convertir, los /nodes/ son instancias particulares, no clases ni /Labels/.

*** Ahora si, la carga.


Para cargarla vamos a utilizar el lenguaje *Cypher*, que es como el SQL para Neo4j.


1. Products

#+begin_src sql
LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/Skalas/nosql2022/main/datasets/products.csv" AS row
CREATE (n:Product)
SET n = row,
n.unitPrice = toFloat(row.unitPrice),
n.unitsInStock = toInteger(row.unitsInStock), n.unitsOnOrder = toInteger(row.unitsOnOrder),
n.reorderLevel = toInteger(row.reorderLevel), n.discontinued = (row.discontinued <> "0")
#+end_src

Qu칠 estamos haciendo aqu칤?

Al igual que SQL, Cypher es un /4th generation language/, que en simples t칠rminos significa que se parece much칤simo a como se estructuran 칩rdenes y declaraciones en ingl칠s.

1. ~LOAD CSV~: el comando de Cypher ~LOAD~ es similar al ~COPY~ de PostgreSQL y MonetDB. La parte de ~WITH HEADERS~, al igual que el ~COPY~ en PostgreSQL indica que el CSV a cargar tiene los nombres de las columnas en el 1er rengl칩n. El keyword ~FROM~ es para indicar la fuente, y afortunadamente para nosotros, Cypher acepta URLs aqu칤, por lo que no es necesario descargar los CSVs a nuestro storage local y solo jalarlos del internet.
2. ~CREATE (n:Product)~ crea el /node/ ~n~ con el /label/ ~Product~. Aqu칤 vale la pena que cubramos unos aspectos de la sintaxis de Cypher:
   - Un /node/ es representado por dos par칠ntesis, a manera de "bolita". El /node/ ~n~ lo representamos como ~(n)~. Por ejemplo: ~create (tonyStark:SuperHero {group:'Avengers'}~
   - Un /edge/ es representado por una flechita como esta ~-[:LABEL]->~ y obviamente debe conectar 2 /nodes/. el ~LABEL~ es igualito a los labels que califican a los nodes, como sigue: ~create (tonyStark)-[:MENTORS]->(peterParker)-[:WORKSFOR]->(jjJameson)~
   - Las /properties/ de un /node/ se fijan con ~{}~ acompa침ando a los /nodes/, como sigue: ~CREATE (tonyStark:SuperHero {group: 'Avengers'})~
   - Igual, las /properties/ de un /edge/ se fijan con ~{}~, as칤: ~create (tonyStark)-[:MENTORS {since:2017}]->(peterParker)-[:WORKSFOR {at:'Daily Bugle'}]->(jjJameson)~
   - Las /properties/, sean de un /edge/ o de un /node/ pueden ser arrays: ~(tonyStark:SuperHero {suits:['Mark IV', 'Mark V']})-[HOLDS {on:['Glove','Avengers Compound']}]->(soulStone:INFINITY/STONE)~
   - Es buena pr치ctica primero crear los /nodes/, luego los /edges/.
3. ~SET n = row~ est치 indicando que al crear los nodos con la variable ~n~, haga una equivalencia entre esa variable y el rengl칩n del archivo CSV que estamos cargando.
4. ~n.unitPrice~ y dem치s comandos est치n preprocesando los datos del archivo CSV para poder guardarlos de forma correcta. ~toInteger~ est치 transformando a entero, mientras que ~n.discontinued~ se est치 evaluando a la expresi칩n ~row.discontinued <> "0"~.
   - 游 OJO 游: esto nos indica que durante la lectura la mayor칤a de los campos se est치n importando como strings.
   - 游 OJO *2 游: la comparaci칩n ~<> "0"~ no es v치lida en Java, pero si lo es en Javascript. Neo4j est치 hecho en Java por debajo, pero tiene un preprocessor de LISP, que es la base de Javascript, que si entiende esta expresi칩n.

Vamos a ejecutar este import en DBeaver:




Y d칩nde est치n las tablas?!


#+DOWNLOADED: screenshot @ 2022-11-10 00:38:09
[[file:images/20221110-003809_screenshot.png]]


Vamos a abrir el cliente de Neo4J apuntando nuestro browser


Veremos que ah칤 est치n nuestros 25 productos:


En esta caja vamos a poder escribir queries en "Cypher". Qu칠 est치 haciendo este query? ~MATCH (n:Product) RETURN n LIMIT 25~.


1. ~MATCH~ es parecido que el ~FROM~.

2. La expresi칩n ~n:Product~ va a buscar los /nodes/ que tengan el /label/ ~Product~.

3. ~RETURN n~ es como la parte del ~SELECT~ donde indicamos las columnas que queremos obtener; en este caso, queremos los nodos, pero bien pudieramos obtener ~n.discontinuied~, o ~n.reorderLevel~, es decir, atributos del (o los) nodo(s) que han hecho match.
